import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Session, SessionDocument } from './schemas/session.schema';
import { CreateSessionDto, SessionType } from './dto/create-session.dto';
import { UpdateSessionDto } from './dto/update-session.dto';
import {
  ScheduleQueryDto,
  GenerateSessionsDto,
  CheckConflictDto,
  BulkCreateSessionsDto,
} from './dto/schedule-query.dto';
import { UserDocument } from '../users/schemas/user.schema';
import { ClassEntity, ClassDocument } from '../classes/schemas/class.schema';

@Injectable()
export class SessionsService {
  constructor(
    @InjectModel(Session.name) private model: Model<SessionDocument>,
    @InjectModel(ClassEntity.name) private classModel: Model<ClassDocument>,
  ) {}

  async create(user: UserDocument, dto: CreateSessionDto) {
    const doc = new this.model({
      ...dto,
      classId: dto.classId ? new Types.ObjectId(dto.classId) : undefined,
      teacherId: dto.teacherId ? new Types.ObjectId(dto.teacherId) : undefined,
      startTime: new Date(dto.startTime),
      endTime: new Date(dto.endTime),
      createdBy: user._id,
    });
    return doc.save();
  }

  findByClass(classId: string) {
    return this.model.find({ classId }).exec();
  }

  findAll() {
    return this.model.find().exec();
  }

  // Lấy lịch theo khoảng thời gian với filter
  async getSchedule(query: ScheduleQueryDto) {
    const { startDate, endDate, teacherId, classId, branchId, status } = query;

    const filter: any = {
      startTime: { $gte: new Date(startDate) },
      endTime: { $lte: new Date(endDate) },
    };

    if (classId) {
      filter.classId = new Types.ObjectId(classId);
    }

    if (status) {
      filter.status = status;
    }

    // Nếu có filter theo teacherId hoặc branchId, cần tìm các classId phù hợp trước
    if (teacherId || branchId) {
      const classFilter: any = {};
      if (teacherId) classFilter.teacherId = new Types.ObjectId(teacherId);
      if (branchId) classFilter.branchId = branchId;

      const classes = await this.classModel
        .find(classFilter)
        .select('_id')
        .exec();
      const classIds = classes.map((c) => c._id);

      if (classId) {
        // Nếu đã có classId filter, kiểm tra xem nó có thuộc về teacher/branch không
        if (!classIds.some((id) => id.toString() === classId)) {
          return []; // classId không thuộc teacher/branch này
        }
      } else {
        filter.classId = { $in: classIds };
      }
    }

    const sessions = await this.model
      .find(filter)
      .populate({
        path: 'classId',
        select: 'name subject teacherId schedule',
        populate: {
          path: 'teacherId',
          select: 'name email subjects',
        },
      })
      .populate('teacherId', 'name email subjects')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .sort({ startTime: 1 })
      .exec();

    return sessions;
  }

  // Kiểm tra xung đột lịch của giáo viên
  async checkConflict(dto: CheckConflictDto) {
    const { teacherId, startTime, endTime, excludeSessionId } = dto;

    // Tìm tất cả lớp của giáo viên này
    const classes = await this.classModel
      .find({ teacherId: new Types.ObjectId(teacherId) })
      .select('_id')
      .exec();
    const classIds = classes.map((c) => c._id);

    if (classIds.length === 0) {
      return { hasConflict: false, conflicts: [] };
    }

    // Tìm sessions trùng thời gian
    const conflictFilter: any = {
      classId: { $in: classIds },
      $or: [
        {
          startTime: { $lt: new Date(endTime) },
          endTime: { $gt: new Date(startTime) },
        },
      ],
      status: { $ne: 'cancelled' },
    };

    if (excludeSessionId) {
      conflictFilter._id = { $ne: new Types.ObjectId(excludeSessionId) };
    }

    const conflicts = await this.model
      .find(conflictFilter)
      .populate('classId', 'name subject')
      .exec();

    return {
      hasConflict: conflicts.length > 0,
      conflicts,
    };
  }

  // Tự động tạo sessions từ schedule của class
  async generateSessions(user: UserDocument, dto: GenerateSessionsDto) {
    const { classId, startDate, endDate, type = SessionType.Regular } = dto;

    const classDoc = await this.classModel.findById(classId).exec();
    if (!classDoc) {
      throw new NotFoundException('Class not found');
    }

    if (!classDoc.schedule || classDoc.schedule.length === 0) {
      throw new BadRequestException('Class has no schedule defined');
    }

    const sessions: Session[] = [];
    const start = new Date(startDate);
    const end = new Date(endDate);

    // Map dayOfWeek string to number (0 = Sunday, 1 = Monday, ...)
    const dayMap: Record<string, number> = {
      sunday: 0,
      monday: 1,
      tuesday: 2,
      wednesday: 3,
      thursday: 4,
      friday: 5,
      saturday: 6,
      'chủ nhật': 0,
      'thứ 2': 1,
      'thứ 3': 2,
      'thứ 4': 3,
      'thứ 5': 4,
      'thứ 6': 5,
      'thứ 7': 6,
    };

    // Iterate through each day from start to end
    const current = new Date(start);
    while (current <= end) {
      const dayOfWeek = current.getDay();

      // Check if this day matches any schedule
      for (const schedule of classDoc.schedule) {
        const scheduleDayNum = schedule.dayOfWeek;

        if (scheduleDayNum === dayOfWeek) {
          // Parse time
          const [startHour, startMin] = schedule.startTime
            .split(':')
            .map(Number);
          const [endHour, endMin] = schedule.endTime.split(':').map(Number);

          const sessionStart = new Date(current);
          sessionStart.setHours(startHour, startMin, 0, 0);

          const sessionEnd = new Date(current);
          sessionEnd.setHours(endHour, endMin, 0, 0);

          // Check if session already exists
          const existing = await this.model
            .findOne({
              classId: new Types.ObjectId(classId),
              startTime: sessionStart,
            })
            .exec();

          if (!existing) {
            const session = new this.model({
              classId: new Types.ObjectId(classId),
              startTime: sessionStart,
              endTime: sessionEnd,
              type,
              status: 'pending',
              createdBy: user._id,
              note: schedule.room ? `Phòng: ${schedule.room}` : undefined,
            });
            const saved = await session.save();
            sessions.push(saved);
          }
        }
      }

      // Move to next day
      current.setDate(current.getDate() + 1);
    }

    return {
      message: `Generated ${sessions.length} sessions`,
      sessions,
    };
  }

  // Tạo nhiều sessions cùng lúc
  async bulkCreate(user: UserDocument, dto: BulkCreateSessionsDto) {
    const { classId, sessions: sessionData } = dto;

    const classDoc = await this.classModel.findById(classId).exec();
    if (!classDoc) {
      throw new NotFoundException('Class not found');
    }

    const created: Session[] = [];
    for (const item of sessionData) {
      const session = new this.model({
        classId: new Types.ObjectId(classId),
        startTime: new Date(item.startTime),
        endTime: new Date(item.endTime),
        type: item.type || SessionType.Regular,
        status: 'pending',
        createdBy: user._id,
        note: item.note,
      });
      const saved = await session.save();
      created.push(saved);
    }

    return created;
  }

  // Lấy lịch của một giáo viên
  async getTeacherSchedule(
    teacherId: string,
    startDate: string,
    endDate: string,
  ) {
    const classes = await this.classModel
      .find({ teacherId: new Types.ObjectId(teacherId) })
      .select('_id name subject')
      .exec();

    const classIds = classes.map((c) => c._id);

    const sessions = await this.model
      .find({
        classId: { $in: classIds },
        startTime: { $gte: new Date(startDate) },
        endTime: { $lte: new Date(endDate) },
        status: { $ne: 'cancelled' },
      })
      .populate('classId', 'name subject')
      .populate('teacherId', 'name email subjects')
      .sort({ startTime: 1 })
      .exec();

    return sessions;
  }

  // Lấy lịch của một học sinh
  async getStudentSchedule(
    studentId: string,
    startDate: string,
    endDate: string,
  ) {
    const classes = await this.classModel
      .find({ studentIds: new Types.ObjectId(studentId) })
      .select('_id name subject teacherId')
      .populate('teacherId', 'name')
      .exec();

    const classIds = classes.map((c) => c._id);

    const sessions = await this.model
      .find({
        classId: { $in: classIds },
        startTime: { $gte: new Date(startDate) },
        endTime: { $lte: new Date(endDate) },
        status: { $ne: 'cancelled' },
      })
      .populate({
        path: 'classId',
        select: 'name subject teacherId',
        populate: {
          path: 'teacherId',
          select: 'name',
        },
      })
      .populate('teacherId', 'name email subjects')
      .sort({ startTime: 1 })
      .exec();

    return sessions;
  }

  // Thống kê sessions
  async getStatistics(startDate: string, endDate: string, branchId?: string) {
    const matchStage: any = {
      startTime: { $gte: new Date(startDate) },
      endTime: { $lte: new Date(endDate) },
    };

    const stats = await this.model.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 },
        },
      },
    ]);

    const total = await this.model.countDocuments(matchStage);

    return {
      total,
      byStatus: stats.reduce(
        (acc, item) => {
          acc[item._id] = item.count;
          return acc;
        },
        {} as Record<string, number>,
      ),
    };
  }

  async update(id: string, dto: UpdateSessionDto, approver?: UserDocument) {
    const updatePayload: any = { ...dto };
    if (dto.status && approver) updatePayload.approvedBy = approver._id;
    if (dto.startTime) updatePayload.startTime = new Date(dto.startTime);
    if (dto.endTime) updatePayload.endTime = new Date(dto.endTime);

    const updated = await this.model
      .findByIdAndUpdate(id, updatePayload, { new: true })
      .exec();
    if (!updated) throw new NotFoundException('Session not found');
    return updated;
  }

  async remove(id: string) {
    const res = await this.model.findByIdAndDelete(id).exec();
    if (!res) throw new NotFoundException('Session not found');
  }

  async findById(id: string) {
    const session = await this.model
      .findById(id)
      .populate({
        path: 'classId',
        select: 'name subject teacherId studentIds',
        populate: {
          path: 'teacherId',
          select: 'name email subjects',
        },
      })
      .populate('teacherId', 'name email subjects')
      .populate('createdBy', 'name email')
      .populate('approvedBy', 'name email')
      .exec();

    if (!session) throw new NotFoundException('Session not found');
    return session;
  }
}
